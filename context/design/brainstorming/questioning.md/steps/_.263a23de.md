---
timestamp: 'Thu Oct 16 2025 19:47:46 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251016_194746.73211cab.md]]'
content_id: 263a23de4e3fdaae7bf2237a50661e301b2c9408e4069de5b1561f9335742a12
---

# RecommendationEngine Concept Specification

## Overview

The RecommendationEngine concept generates and manages personalized place recommendations for users based on their preferences, saved places, and tasting history.

## State

### Types

* `User`: Unique identifier for a user
* `Place`: Unique identifier for a place
* `DateTime`: Date object representing a timestamp

### State Components

* `recommendations`: A collection mapping users to their recommended places:
  * `_id`: User - the user ID
  * `places`: Place\[] - array of recommended place IDs
* `lastUpdated`: A collection mapping users to when their recommendations were last updated:
  * `_id`: User - the user ID
  * `timestamp`: DateTime - when recommendations were last computed

### Constants

* `RECOMMENDATION_REFRESH_INTERVAL`: 24 hours (1000 \* 60 \* 60 \* 24 milliseconds)

## Actions

### `get_recommendations({userId})`

Retrieves recommendations for a user, computing fresh ones if needed.

**Parameters:**

* `userId`: User - the user to get recommendations for

**Returns:** {places: Place\[]} - object containing array of recommended place IDs

**Preconditions:**

* None (will compute recommendations if none exist)

**Postconditions:**

* If recommendations exist and are recent (< 24 hours old), returns cached recommendations
* If recommendations are stale or don't exist, computes and caches fresh recommendations
* Updates the `lastUpdated` timestamp

### `refresh_recommendations({userId, savedPlaces, preferences, triedPlaces})`

Forces a refresh of recommendations for a user with current data.

**Parameters:**

* `userId`: User - the user to refresh recommendations for
* `savedPlaces`: Place\[] - places the user has saved
* `preferences`: Map\<string, string> - user preferences
* `triedPlaces`: Place\[] - places the user has already tried

**Returns:** Record\<PropertyKey, never> - empty object indicating success

**Preconditions:**

* None

**Postconditions:**

* Fresh recommendations are computed based on the provided data
* Recommendations are cached in the database
* `lastUpdated` timestamp is set to current time

### `clear_recommendations({userId})`

Removes all recommendation data for a user.

**Parameters:**

* `userId`: User - the user to clear recommendations for

**Returns:** Record\<PropertyKey, never> - empty object indicating success

**Preconditions:**

* None

**Postconditions:**

* All recommendation data for the user is removed
* Both `recommendations` and `lastUpdated` entries are deleted

## Queries

### `_get_user_recommendations({userId})`

Internal query to retrieve cached recommendations for a user.

**Parameters:**

* `userId`: User - the user to query

**Returns:** {places: Place\[]} - cached recommendations or empty array if none exist

### `_get_last_updated({userId})`

Internal query to retrieve the last update timestamp for a user's recommendations.

**Parameters:**

* `userId`: User - the user to query

**Returns:** {timestamp: DateTime} - the last update timestamp

**Preconditions:**

* Recommendations must exist for the user

**Throws:** Error if no timestamp exists for the user

## Recommendation Algorithm

The `compute_suggestions` method implements a simplified recommendation algorithm:

1. **Filter tried places**: Excludes places the user has already visited
2. **Prioritize saved places**: Places the user has saved are given higher priority
3. **Include other places**: Adds other available places that haven't been tried
4. **Special case handling**: For users with exactly one saved place and no tried places, returns only the saved place

This algorithm ensures that:

* Users don't get recommendations for places they've already tried
* Saved places are prioritized in recommendations
* Users always get some recommendations when available
