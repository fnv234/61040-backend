---
timestamp: 'Thu Oct 16 2025 19:43:29 GMT-0400 (Eastern Daylight Time)'
content_id: f7adf7c995c32b3d2b5042066593dd602e98f76a029fe3dd59d0211e54eb9eb6
---

# file: src/concepts/UserDirectory/UserDirectoryConcept.test.ts

```typescript
import { assertEquals } from "jsr:@std/assert";
import { testDb } from "@utils/database.ts";
import UserDirectoryConcept from "./UserDirectoryConcept.ts";

Deno.test("UserDirectoryConcept", async (t) => {
  const [db, client] = await testDb();

  const userDirectory = new UserDirectoryConcept(db);

  // Helper to generate fake IDs
  const fakeUserId = (name: string) => `user:${name}` as any;
  const fakePlaceId = (name: string) => `place:${name}` as any;

  await t.step("register_user should create a new user", async () => {
    const userId = fakeUserId("Alice");
    const displayName = "Alice Wonderland";
    const email = "alice@example.com";

    const result = await userDirectory.register_user({
      userId,
      displayName,
      email,
    });

    assertEquals(result, userId, "Should return the created user ID");

    const user = await db.collection("UserDirectory.users").findOne({
      _id: userId,
    });
    assertEquals(user?.displayName, displayName, "DisplayName should match");
    assertEquals(user?.email, email, "Email should match");
    assertEquals(
      user?.savedPlaces,
      [],
      "Saved places should be empty initially",
    );
    assertEquals(
      user?.preferences,
      {},
      "Preferences should be empty initially",
    );
  });

  await t.step("register_user should fail if user already exists", async () => {
    const userId = fakeUserId("Bob");
    const displayName = "Bob The Builder";
    const email = "bob@example.com";

    // First registration should succeed
    await userDirectory.register_user({ userId, displayName, email });

    // Second registration with the same userId should fail
    const result = await userDirectory.register_user({
      userId,
      displayName,
      email,
    });
    assertEquals(result, {
      error: `User with userId ${userId} already exists.`,
    });
  });

  await t.step(
    "register_user should fail with empty displayName or email",
    async () => {
      const userId = fakeUserId("Charlie");
      const existingUserId = fakeUserId("Alice"); // Ensure this user exists to avoid conflict

      // Create Alice first to have a user to check against
      await userDirectory.register_user({
        userId: existingUserId,
        displayName: "Alice Wonderland",
        email: "alice@example.com",
      });

      const resultEmptyName = await userDirectory.register_user({
        userId,
        displayName: "",
        email: "charlie@example.com",
      });
      assertEquals(resultEmptyName, {
        error: "DisplayName and email cannot be empty.",
      });

      const resultEmptyEmail = await userDirectory.register_user({
        userId,
        displayName: "Charlie",
        email: "",
      });
      assertEquals(resultEmptyEmail, {
        error: "DisplayName and email cannot be empty.",
      });
    },
  );

  await t.step(
    "save_place should add a place to a user's saved places",
    async () => {
      const userId = fakeUserId("David");
      const placeId1 = fakePlaceId("Park");
      const placeId2 = fakePlaceId("Museum");

      await userDirectory.register_user({
        userId,
        displayName: "David",
        email: "david@example.com",
      });

      // Save the first place
      const result1 = await userDirectory.save_place({
        userId,
        placeId: placeId1,
      });
      assertEquals(result1, {}, "Should return empty object on success");

      const user1 = await db.collection("UserDirectory.users").findOne({
        _id: userId,
      });
      assertEquals(
        user1?.savedPlaces,
        [placeId1],
        "Should contain the first saved place",
      );

      // Save the second place
      const result2 = await userDirectory.save_place({
        userId,
        placeId: placeId2,
      });
      assertEquals(result2, {}, "Should return empty object on success");

      const user2 = await db.collection("UserDirectory.users").findOne({
        _id: userId,
      });
      assertEquals(
        user2?.savedPlaces,
        [placeId1, placeId2],
        "Should contain both saved places",
      );
    },
  );

  await t.step(
    "save_place should not add a place if it's already saved",
    async () => {
      const userId = fakeUserId("Eve");
      const placeId = fakePlaceId("Cafe");

      await userDirectory.register_user({
        userId,
        displayName: "Eve",
        email: "eve@example.com",
      });
      await userDirectory.save_place({ userId, placeId });

      const userBefore = await db.collection("UserDirectory.users").findOne({
        _id: userId,
      });
      assertEquals(
        userBefore?.savedPlaces?.length,
        1,
        "Saved places should have 1 item before re-saving",
      );

      const result = await userDirectory.save_place({ userId, placeId });
      assertEquals(
        result,
        {},
        "Should return empty object even if already saved",
      );

      const userAfter = await db.collection("UserDirectory.users").findOne({
        _id: userId,
      });
      assertEquals(
        userAfter?.savedPlaces?.length,
        1,
        "Saved places should still have 1 item after re-saving",
      );
      assertEquals(
        userAfter?.savedPlaces,
        [placeId],
        "The saved place should remain the same",
      );
    },
  );

  await t.step("save_place should fail if user not found", async () => {
    const nonExistentUserId = fakeUserId("Ghost");
    const placeId = fakePlaceId("Spooky House");

    const result = await userDirectory.save_place({
      userId: nonExistentUserId,
      placeId,
    });
    assertEquals(result, {
      error: `User with userId ${nonExistentUserId} not found.`,
    });
  });

  await t.step(
    "unsave_place should remove a place from a user's saved places",
    async () => {
      const userId = fakeUserId("Frank");
      const placeId1 = fakePlaceId("Beach");
      const placeId2 = fakePlaceId("Mountain");

      await userDirectory.register_user({
        userId,
        displayName: "Frank",
        email: "frank@example.com",
      });
      await userDirectory.save_place({ userId, placeId: placeId1 });
      await userDirectory.save_place({ userId, placeId: placeId2 });

      const userBefore = await db.collection("UserDirectory.users").findOne({
        _id: userId,
      });
      assertEquals(
        userBefore?.savedPlaces,
        [placeId1, placeId2],
        "User should have two saved places initially",
      );

      // Unsave the first place
      const result1 = await userDirectory.unsave_place({
        userId,
        placeId: placeId1,
      });
      assertEquals(result1, {}, "Should return empty object on success");

      const user1 = await db.collection("UserDirectory.users").findOne({
        _id: userId,
      });
      assertEquals(
        user1?.savedPlaces,
        [placeId2],
        "Should contain only the second saved place",
      );

      // Unsave the second place
      const result2 = await userDirectory.unsave_place({
        userId,
        placeId: placeId2,
      });
      assertEquals(result2, {}, "Should return empty object on success");

      const user2 = await db.collection("UserDirectory.users").findOne({
        _id: userId,
      });
      assertEquals(
        user2?.savedPlaces,
        [],
        "Saved places should be empty after unsaving both",
      );
    },
  );

  await t.step("unsave_place should fail if user not found", async () => {
    const nonExistentUserId = fakeUserId("Ghost");
    const placeId = fakePlaceId("Haunted Mansion");

    const result = await userDirectory.unsave_place({
      userId: nonExistentUserId,
      placeId,
    });
    assertEquals(result, {
      error: `User with userId ${nonExistentUserId} not found.`,
    });
  });

  await t.step("unsave_place should fail if place not saved", async () => {
    const userId = fakeUserId("Grace");
    const placeId = fakePlaceId("Library");
    const notSavedPlaceId = fakePlaceId("Zoo");

    await userDirectory.register_user({
      userId,
      displayName: "Grace",
      email: "grace@example.com",
    });
    await userDirectory.save_place({ userId, placeId }); // Save one place

    const result = await userDirectory.unsave_place({
      userId,
      placeId: notSavedPlaceId,
    });
    assertEquals(result, {
      error:
        `PlaceId ${notSavedPlaceId} not found in saved places for user ${userId}.`,
    });
  });

  await t.step(
    "update_preferences should update a user's preferences",
    async () => {
      const userId = fakeUserId("Heidi");
      const initialPrefs = { theme: "dark", notifications: "email" };
      const updatedPrefs = { theme: "light", language: "en" };

      await userDirectory.register_user({
        userId,
        displayName: "Heidi",
        email: "heidi@example.com",
      });
      await userDirectory.update_preferences({
        userId,
        newPrefs: initialPrefs,
      });

      const user1 = await db.collection("UserDirectory.users").findOne({
        _id: userId,
      });
      assertEquals(
        user1?.preferences,
        initialPrefs,
        "Preferences should be updated to initialPrefs",
      );

      await userDirectory.update_preferences({
        userId,
        newPrefs: updatedPrefs,
      });
      const user2 = await db.collection("UserDirectory.users").findOne({
        _id: userId,
      });
      assertEquals(
        user2?.preferences,
        updatedPrefs,
        "Preferences should be updated to updatedPrefs",
      );
    },
  );

  await t.step("update_preferences should fail if user not found", async () => {
    const nonExistentUserId = fakeUserId("Ghost");
    const prefs = { setting: "value" };

    const result = await userDirectory.update_preferences({
      userId: nonExistentUserId,
      newPrefs: prefs,
    });
    assertEquals(result, {
      error: `User with userId ${nonExistentUserId} not found.`,
    });
  });

  await t.step(
    "get_saved_places should return the saved places for a user",
    async () => {
      const userId = fakeUserId("Ivy");
      const placeId1 = fakePlaceId("Cinema");
      const placeId2 = fakePlaceId("Park");

      await userDirectory.register_user({
        userId,
        displayName: "Ivy",
        email: "ivy@example.com",
      });
      await userDirectory.save_place({ userId, placeId: placeId1 });
      await userDirectory.save_place({ userId, placeId: placeId2 });

      const savedPlaces = await userDirectory.get_saved_places({ userId });
      assertEquals(
        savedPlaces,
        [placeId1, placeId2],
        "Should return the correct list of saved places",
      );
    },
  );

  await t.step(
    "get_saved_places should return an empty array for a user with no saved places",
    async () => {
      const userId = fakeUserId("Jack");

      await userDirectory.register_user({
        userId,
        displayName: "Jack",
        email: "jack@example.com",
      });

      const savedPlaces = await userDirectory.get_saved_places({ userId });
      assertEquals(savedPlaces, [], "Should return an empty array");
    },
  );

  await t.step("get_saved_places should fail if user not found", async () => {
    const nonExistentUserId = fakeUserId("Ghost");

    const result = await userDirectory.get_saved_places({
      userId: nonExistentUserId,
    });
    assertEquals(result, {
      error: `User with userId ${nonExistentUserId} not found.`,
    });
  });

  await t.step(
    "principle: each user maintains independent saved places and preferences",
    async () => {
      const userIdAlice = fakeUserId("Alice");
      const userIdBob = fakeUserId("Bob");

      const placeIdAlice1 = fakePlaceId("Alice_Place1");
      const placeIdAlice2 = fakePlaceId("Alice_Place2");
      const placeIdBob1 = fakePlaceId("Bob_Place1");

      const alicePrefs = { theme: "dark" };
      const bobPrefs = { theme: "light", language: "fr" };

      // Alice registers
      await userDirectory.register_user({
        userId: userIdAlice,
        displayName: "Alice",
        email: "alice@example.com",
      });
      // Bob registers
      await userDirectory.register_user({
        userId: userIdBob,
        displayName: "Bob",
        email: "bob@example.com",
      });

      // Alice saves places and updates preferences
      await userDirectory.save_place({
        userId: userIdAlice,
        placeId: placeIdAlice1,
      });
      await userDirectory.save_place({
        userId: userIdAlice,
        placeId: placeIdAlice2,
      });
      await userDirectory.update_preferences({
        userId: userIdAlice,
        newPrefs: alicePrefs,
      });

      // Bob saves places and updates preferences
      await userDirectory.save_place({
        userId: userIdBob,
        placeId: placeIdBob1,
      });
      await userDirectory.update_preferences({
        userId: userIdBob,
        newPrefs: bobPrefs,
      });

      // Verify Alice's state
      const aliceUser = await db.collection("UserDirectory.users").findOne({
        _id: userIdAlice,
      });
      assertEquals(
        aliceUser?.savedPlaces,
        [placeIdAlice1, placeIdAlice2],
        "Alice's saved places should be correct",
      );
      assertEquals(
        aliceUser?.preferences,
        alicePrefs,
        "Alice's preferences should be correct",
      );

      // Verify Bob's state
      const bobUser = await db.collection("UserDirectory.users").findOne({
        _id: userIdBob,
      });
      assertEquals(
        bobUser?.savedPlaces,
        [placeIdBob1],
        "Bob's saved places should be correct",
      );
      assertEquals(
        bobUser?.preferences,
        bobPrefs,
        "Bob's preferences should be correct",
      );

      // Verify that Alice's actions did not affect Bob
      const bobUserAfterAliceActions = await db.collection(
        "UserDirectory.users",
      ).findOne({ _id: userIdBob });
      assertEquals(
        bobUserAfterAliceActions?.savedPlaces,
        [placeIdBob1],
        "Bob's saved places should remain unchanged after Alice's actions",
      );
      assertEquals(
        bobUserAfterAliceActions?.preferences,
        bobPrefs,
        "Bob's preferences should remain unchanged after Alice's actions",
      );

      // Verify that Bob's actions did not affect Alice
      const aliceUserAfterBobActions = await db.collection(
        "UserDirectory.users",
      ).findOne({ _id: userIdAlice });
      assertEquals(aliceUserAfterBobActions?.savedPlaces, [
        placeIdAlice1,
        placeIdAlice2,
      ], "Alice's saved places should remain unchanged after Bob's actions");
      assertEquals(
        aliceUserAfterBobActions?.preferences,
        alicePrefs,
        "Alice's preferences should remain unchanged after Bob's actions",
      );
    },
  );

  await client.close();
});

```
