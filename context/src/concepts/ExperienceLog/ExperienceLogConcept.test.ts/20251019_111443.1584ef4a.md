---
timestamp: 'Sun Oct 19 2025 11:14:43 GMT-0400 (Eastern Daylight Time)'
content_id: 1584ef4acf20b51cfdb565c8eca7ed3caf621d46002fb8dae32765432fd86e39
---

# file: src/concepts/ExperienceLog/ExperienceLogConcept.test.ts

```typescript
import { testDb } from "@utils/database.ts";
import { assertEquals } from "jsr:@std/assert";
import ExperienceLogConcept from "./ExperienceLogConcept.ts";
import { mockLLM } from "../../../gemini-llm.ts";
import { ID } from "@utils/types.ts";

Deno.test("ExperienceLog - Create, Update, Delete Logs", async (t) => {
  const [db, client] = await testDb();
  const experienceLog = new ExperienceLogConcept(db);

  try {
    const user1 = "user:user1" as ID;
    const placeA = "place:placeA" as ID;
    const placeB = "place:placeB" as ID;
    const user2 = "user:user2" as ID;

    await t.step("create_log should create a log", async () => {
      const result = await experienceLog.create_log({
        userId: user1,
        placeId: placeA,
        rating: 5,
        sweetness: 5,
        strength: 5,
        notes: "Great experience!",
        photo: "http://example.com/photo.jpg",
      });
      if ("error" in result) throw new Error(result.error);
      const logId = result.logId;

      const logsResult = await experienceLog._get_user_logs({ userId: user1 });
      const log = logsResult.logs.find((l) => l._id === logId);

      assertEquals(log?.userId, user1);
      assertEquals(log?.placeId, placeA);
      assertEquals(log?.rating, 5);
      assertEquals(log?.sweetness, 5);
      assertEquals(log?.strength, 5);
      assertEquals(log?.notes, "Great experience!");
      assertEquals(log?.photo, "http://example.com/photo.jpg");
      assertEquals(typeof log?._id, "string");
      assertEquals(log?.timestamp instanceof Date, true);
    });

    await t.step("create_log should return error for invalid rating", async () => {
      const result1 = await experienceLog.create_log({ userId: user1, placeId: placeA, rating: 0, sweetness: 5, strength: 5 });
      assertEquals(result1, { error: "Rating must be 1–5" });

      const result2 = await experienceLog.create_log({ userId: user1, placeId: placeA, rating: 6, sweetness: 5, strength: 5 });
      assertEquals(result2, { error: "Rating must be 1–5" });
    });

    await t.step("create_log should return error for invalid sweetness", async () => {
      const result1 = await experienceLog.create_log({ userId: user1, placeId: placeA, rating: 5, sweetness: 0, strength: 5 });
      assertEquals(result1, { error: "Sweetness must be 1–5" });

      const result2 = await experienceLog.create_log({ userId: user1, placeId: placeA, rating: 5, sweetness: 6, strength: 5 });
      assertEquals(result2, { error: "Sweetness must be 1–5" });
    });

    await t.step("create_log should return error for invalid strength", async () => {
      const result1 = await experienceLog.create_log({ userId: user1, placeId: placeA, rating: 5, sweetness: 5, strength: 0 });
      assertEquals(result1, { error: "Strength must be 1–5" });

      const result2 = await experienceLog.create_log({ userId: user1, placeId: placeA, rating: 5, sweetness: 5, strength: 6 });
      assertEquals(result2, { error: "Strength must be 1–5" });
    });

    const initialLogResult = await experienceLog.create_log({
      userId: user1,
      placeId: placeA,
      rating: 4,
      sweetness: 3,
      strength: 4,
    });
    if ("error" in initialLogResult) throw new Error(initialLogResult.error);
    const initialLogId = initialLogResult.logId;

    await t.step("update_log should update a log", async () => {
      const updatedLogResult = await experienceLog.update_log({
        logId: initialLogId,
        rating: 5,
        notes: "Even better this time!",
      });
      if ("error" in updatedLogResult) throw new Error(updatedLogResult.error);
      const updatedLog = updatedLogResult.log;

      assertEquals(updatedLog.rating, 5);
      assertEquals(updatedLog.notes, "Even better this time!");
      assertEquals(updatedLog._id, initialLogId);
    });

    await t.step(
      "update_log should return error when updating non-existent log",
      async () => {
        const result = await experienceLog.update_log({ logId: "non-existent-log" as ID, rating: 5 });
        assertEquals(result, { error: "Log not found" });
      },
    );
    
    await t.step("update_log should return error for invalid rating in update", async () => {
      const result = await experienceLog.update_log({ logId: initialLogId, rating: 0 });
      assertEquals(result, { error: "Rating must be 1–5" });
    });

    await t.step("delete_log should delete a log", async () => {
      const logToDeleteResult = await experienceLog.create_log({
        userId: user2,
        placeId: placeB,
        rating: 3,
        sweetness: 3,
        strength: 3,
      });
      if ("error" in logToDeleteResult) throw new Error(logToDeleteResult.error);
      const logToDeleteId = logToDeleteResult.logId;

      const deleteResult = await experienceLog.delete_log({ logId: logToDeleteId });
      assertEquals(deleteResult, {});

      const user2LogsResult = await experienceLog._get_user_logs({ userId: user2 });
      assertEquals(user2LogsResult.logs.length, 0);
    });

    await t.step(
      "delete_log should return error when deleting non-existent log",
      async () => {
        const result = await experienceLog.delete_log({ logId: "non-existent-log" as ID });
        assertEquals(result, { error: "Log not found" });
      },
    );
  } finally {
    await client.close();
  }
});

Deno.test("ExperienceLog - Getters and Queries", async (t) => {
  const [db, client] = await testDb();
  const experienceLog = new ExperienceLogConcept(db);

  try {
    const user1 = "user:user1" as ID;
    const user2 = "user:user2" as ID;
    const user3 = "user:user3" as ID;
    const placeA = "place:placeA" as ID;
    const placeB = "place:placeB" as ID;
    const placeC = "place:placeC" as ID;

    const log1Result = await experienceLog.create_log({ userId: user1, placeId: placeA, rating: 5, sweetness: 5, strength: 5 });
    if ("error" in log1Result) throw new Error(log1Result.error);
    const log1Id = log1Result.logId;

    const log2Result = await experienceLog.create_log({ userId: user1, placeId: placeB, rating: 4, sweetness: 3, strength: 4 });
    if ("error" in log2Result) throw new Error(log2Result.error);
    const log2Id = log2Result.logId;

    const log3Result = await experienceLog.create_log({ userId: user2, placeId: placeA, rating: 3, sweetness: 2, strength: 2 });
    if ("error" in log3Result) throw new Error(log3Result.error);
    const log3Id = log3Result.logId;

    const log4Result = await experienceLog.create_log({ userId: user1, placeId: placeA, rating: 3, sweetness: 3, strength: 3 });
    if ("error" in log4Result) throw new Error(log4Result.error);
    const log4Id = log4Result.logId;

    await t.step(
      "_get_user_logs should return all logs for a user",
      async () => {
        const userLogsResult = await experienceLog._get_user_logs({ userId: user1 });
        const userLogs = userLogsResult.logs;
        assertEquals(userLogs.length, 3);
        assertEquals(userLogs.some((l) => l._id === log1Id), true);
        assertEquals(userLogs.some((l) => l._id === log2Id), true);
        assertEquals(userLogs.some((l) => l._id === log4Id), true);
      },
    );

    await t.step(
      "_get_place_logs should return logs for a specific user and place",
      async () => {
        const placeLogsResult = await experienceLog._get_place_logs({
          userId: user1,
          placeId: placeA,
        });
        const placeLogs = placeLogsResult.logs;
        assertEquals(placeLogs.length, 2);
        assertEquals(placeLogs.some((l) => l._id === log1Id), true);
        assertEquals(placeLogs.some((l) => l._id === log4Id), true);
      },
    );

    await t.step(
      "_get_average_rating should calculate the average rating correctly",
      async () => {
        const avg1 = await experienceLog._get_average_rating({
          userId: user1,
          placeId: placeA,
        });
        if ("error" in avg1) throw new Error(avg1.error);
        assertEquals(avg1.averageRating, 4); // (5+3)/2

        const avg2 = await experienceLog._get_average_rating({
          userId: user1,
          placeId: placeB,
        });
        if ("error" in avg2) throw new Error(avg2.error);
        assertEquals(avg2.averageRating, 4);

        const avg3 = await experienceLog._get_average_rating({
          userId: user2,
          placeId: placeA,
        });
        if ("error" in avg3) throw new Error(avg3.error);
        assertEquals(avg3.averageRating, 3);

        const avg4 = await experienceLog._get_average_rating({
          userId: user3,
          placeId: placeC,
        });
        assertEquals(avg4, { error: "No logs found for this user and place." });
      },
    );

    await t.step(
      "_get_tried_places should return unique places a user has visited",
      async () => {
        const triedPlacesResult = await experienceLog._get_tried_places({ userId: user1 });
        const triedPlaces = triedPlacesResult.places;
        assertEquals(triedPlaces.length, 2);
        assertEquals(triedPlaces.includes(placeA), true);
        assertEquals(triedPlaces.includes(placeB), true);

        const user2TriedPlacesResult = await experienceLog._get_tried_places({ userId: user2 });
        const user2TriedPlaces = user2TriedPlacesResult.places;
        assertEquals(user2TriedPlaces.length, 1);
        assertEquals(user2TriedPlaces.includes(placeA), true);

        const user3TriedPlacesResult = await experienceLog._get_tried_places({ userId: user3 });
        const user3TriedPlaces = user3TriedPlacesResult.places;
        assertEquals(user3TriedPlaces.length, 0);
      },
    );
  } finally {
    await client.close();
  }
});

Deno.test("ExperienceLog - AI Profile Summary", async (t) => {
  const [db, client] = await testDb();
  const experienceLog = new ExperienceLogConcept(db);
  const llm = mockLLM();

  try {
    const user1 = "user:user1" as ID;
    const userNonExistent = "user:nonexistent" as ID;
    const placeA = "place:placeA" as ID;
    const placeB = "place:placeB" as ID;

    // Mock LLM response and capture prompt
    let capturedPrompt = "";
    llm.executeLLM = async (prompt: string) => {
      capturedPrompt = prompt;
      return "You generally prefer sweeter and stronger matcha, with a slight tendency towards higher ratings. Your experiences at places like 'place:placeA' have been mixed, while 'place:placeB' was consistently enjoyed.";
    };

    await experienceLog.create_log({ userId: user1, placeId: placeA, rating: 5, sweetness: 5, strength: 5, notes: "Loved it!" });
    await experienceLog.create_log({ userId: user1, placeId: placeB, rating: 4, sweetness: 3, strength: 4, notes: "Good, but could be sweeter." });
    await experienceLog.create_log({ userId: user1, placeId: placeA, rating: 3, sweetness: 3, strength: 3, notes: "A bit too bitter." });

    await t.step("should generate a profile summary using LLM", async () => {
      const summaryResult = await experienceLog.generate_profile_summary({ userId: user1, llm });
      if ("error" in summaryResult) throw new Error(summaryResult.error);
      const summary = summaryResult.summary;

      assertEquals(
        summary,
        "You generally prefer sweeter and stronger matcha, with a slight tendency towards higher ratings. Your experiences at places like 'place:placeA' have been mixed, while 'place:placeB' was consistently enjoyed.",
      );

      // Assert LLM was called with correct prompt (simplified check)
      const prompt = capturedPrompt;
      assertEquals(prompt.includes(`User ID: ${user1}`), true);
      assertEquals(prompt.includes("Average rating: 4.0"), true);
      assertEquals(prompt.includes("Average sweetness: 3.7"), true);
      assertEquals(prompt.includes("Average strength: 4.0"), true);
      assertEquals(prompt.includes(`Places tried: ${placeA}, ${placeB}`), true);
      assertEquals(prompt.includes("Recent logs:"), true);
    });

    await t.step("should return error if no logs exist for user", async () => {
      const result = await experienceLog.generate_profile_summary({ userId: userNonExistent, llm });
      assertEquals(result, { error: "No logs for this user" });
    });

    // Test LLM validation - simplified tests
    await t.step("should handle validation errors gracefully", async () => {
      // Test that the method returns an error when validation fails
      // Use a capitalized place name that the validator will detect
      llm.executeLLM = async () =>
        "You enjoyed Fake Matcha Cafe, which is a great spot."; // Fake Matcha Cafe is not in user's logs
      const result = await experienceLog.generate_profile_summary({ userId: user1, llm });
      assertEquals(
        "error" in result && result.error.includes("Summary validation failed"),
        true,
        "Expected validation error for fabricated place in summary",
      );
    });
  } finally {
    await client.close();
  }
});
```
